# ADR-004: Разделение полей бухгалтера в модели Chat

## Статус

Принято

## Дата

2026-02-27

## Контекст

Модель `Chat` хранит информацию о Telegram-чатах клиентов и их привязке к бухгалтерам. В системе существует три разных сценария работы с бухгалтером чата:

1. **Админ-панель**: администратор назначает бухгалтеров по @username — это единственный идентификатор, который человек знает наизусть.
2. **Уведомления**: сервисы `alert.service.ts` и `escalation.service.ts` отправляют Telegram-сообщения по числовому Telegram ID (BigInt). Повторный поиск ID по username при каждом алерте — лишняя нагрузка на БД.
3. **Авторизация**: проверка доступа (`requireChatAccess`, фильтрация для роли `observer`) требует UUID-ссылку на модель `User` для Prisma-реляций.

Попытка объединить всё в одно поле неизбежно приводит к компромиссам: либо UI усложняется (нужно вводить UUID), либо уведомления замедляются (lookup на каждый алерт), либо авторизация теряет реляционные связи.

## Решение

Модель `Chat` использует три отдельных поля, каждое обслуживает свой слой системы:

### `accountantUsernames: String[]` — UI-слой

```prisma
accountantUsernames String[] @default([]) @map("accountant_usernames")
```

- Telegram @username бухгалтеров, вводимые администратором в интерфейсе.
- Поддерживает несколько бухгалтеров на один чат.
- Валидируются при сохранении: username должен существовать в таблице `User`.
- Когда задан `assignedAccountantId`, username назначенного бухгалтера автоматически добавляется в массив.
- Источник правды с точки зрения человека: «кто отвечает за этот чат».

### `accountantTelegramIds: BigInt[]` — слой уведомлений

```prisma
accountantTelegramIds BigInt[] @default([]) @map("accountant_telegram_ids") @db.BigInt
```

- Автоматически заполняется при вызове мутации `chats.update` путём резолва username → telegramId через таблицу `User` (gh-68).
- Никогда не редактируется напрямую — только пересчитывается из `accountantUsernames`.
- Тип BigInt соответствует формату Telegram API.
- Используется `getRecipientsByLevel()` в `config.service.ts` для двухуровневой эскалации.
- Исключает повторные запросы к БД при массовой отправке алертов.

### `assignedAccountantId: String? (UUID)` — слой авторизации

```prisma
assignedAccountantId String? @map("assigned_accountant_id") @db.Uuid
```

- Ссылка на модель `User` через Prisma-реляцию `@relation("AssignedAccountant")`.
- Один «основной» бухгалтер (в отличие от массива usernames).
- Используется для:
  - Проверки доступа: роль `observer` видит только чаты, где `assignedAccountantId = ctx.user.id`.
  - Фильтрации в списке чатов (`where.assignedAccountantId`).
  - Выпадающего списка назначения в UI.
- При установке username назначенного бухгалтера автоматически попадает в `accountantUsernames`.

### Двухуровневая эскалация уведомлений

Функция `getRecipientsByLevel()` реализует каскад:

| Уровень | Получатели | Fallback |
|---------|-----------|----------|
| Level 1 (первичный breach) | `accountantTelegramIds` | → `managerTelegramIds` → `globalManagerIds` |
| Level 2+ (эскалация) | `managerTelegramIds` + `accountantTelegramIds` (дедупликация) | → `globalManagerIds` |

Разделение полей обеспечивает этот паттерн: сначала уведомляем бухгалтеров, затем подключаем менеджеров.

## Рассмотренные альтернативы

### Альтернатива 1: Единое поле `assignedAccountantId` (UUID)

Хранить только UUID, резолвить username и telegramId на лету.

**Плюсы:**
- Одно поле — простая схема.
- Реляционная целостность через FK.

**Минусы:**
- Поддержка только одного бухгалтера на чат.
- Администратору нужно знать UUID или выбирать из списка (менее удобно, чем ввод @username).
- Каждое уведомление требует JOIN для получения telegramId — неприемлемо при высокой частоте алертов.

### Альтернатива 2: JSON-поле со всеми данными

Одно JSON-поле `accountants: { username, telegramId, userId }[]`.

**Плюсы:**
- Одно поле, все данные вместе.

**Минусы:**
- Нет типизации на уровне БД, нет FK-constraint.
- Невозможно создать индекс по `assignedAccountantId` для фильтрации.
- Prisma не поддерживает типизированные JSON-массивы — теряется type safety.
- Нужна ручная синхронизация при изменении username или telegramId пользователя.

### Альтернатива 3: Промежуточная таблица `ChatAccountant`

Связующая таблица many-to-many с полями `chatId`, `userId`, `role`.

**Плюсы:**
- Нормализованная схема, реляционная целостность.
- Гибкие роли (primary, secondary).

**Минусы:**
- Дополнительная таблица и JOIN на каждый запрос.
- Telegram ID всё равно нужно резолвить через User — та же проблема с производительностью уведомлений.
- Значительное усложнение мутаций (вместо `chat.update` нужен upsert связей).
- Избыточно для текущих требований (2-5 бухгалтеров на чат).

## Последствия

### Позитивные

- **Производительность уведомлений**: telegramId готовы к использованию без дополнительных запросов.
- **Удобство UI**: администратор работает с @username, не с числовыми ID.
- **Целостность авторизации**: UUID-ссылка обеспечивает FK и индексирование.
- **Поддержка эскалации**: разделение accountant/manager ID включает двухуровневую маршрутизацию.
- **Идемпотентность**: `accountantTelegramIds` пересчитывается при каждом обновлении — данные не рассинхронизируются.

### Негативные

- **Три поля вместо одного**: новому разработчику нужно понять назначение каждого.
- **Дублирование данных**: username и telegramId пользователя хранятся и в `User`, и в `Chat`.
- **Риск рассинхронизации**: если пользователь сменит username в Telegram, `accountantUsernames` станет неактуальным до следующего обновления чата.
- **Фоновая задача**: для случаев, когда telegramId не удалось резолвить сразу, существует `missing-telegram-ids.job.ts`.

### Митигация

- Документация полей в Prisma-схеме (JSDoc-комментарии).
- Автоматическое заполнение `accountantTelegramIds` при каждом `chats.update`.
- Фоновая задача `missing-telegram-ids.job.ts` дорезолвит ID асинхронно.
- Данный ADR для онбординга новых разработчиков.

## Связанные решения

- **gh-68**: Auto-populate `accountantTelegramIds` при обновлении чата
- **gh-76**: Дифференцированные SLA по тарифу клиента (`clientTier`)
- **gh-185**: Фильтрация чатов по `assignedAccountantId` для роли `observer`
- **gh-209**: Soft-delete в модели Chat
- **gh-210**: Двухуровневая эскалация уведомлений
